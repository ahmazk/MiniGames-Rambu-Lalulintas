<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Mini City 3D (High Poly Version)</title>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background: #aee6ff;
      }
      #overlay {
        position: absolute;
        top: 20px;
        left: 20px;
        color: white;
        font-family: sans-serif;
        background: rgba(0, 0, 0, 0.3);
        padding: 8px 12px;
        border-radius: 8px;
      }
    </style>
  </head>
  <body>
    <div id="overlay">
      üèôÔ∏è Mini City (High Poly Mode)<br />
      <small
        >Gunakan <b>W A S D</b> untuk bergerak ‚Ä¢ Klik layar untuk mengunci
        mouse</small
      >
    </div>

    <!-- === THREE.JS LIBRARIES === -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/js/controls/PointerLockControls.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/js/loaders/FontLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r150/examples/js/geometries/TextGeometry.js"></script>

    <script>
      let scene, camera, renderer, controls;
      let moveForward = false,
        moveBackward = false,
        moveLeft = false,
        moveRight = false,
        sprint = false;

      const clock = new THREE.Clock();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();

      init();
      animate();

      function init() {
        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xaee6ff);

        // === CAMERA ===
        camera = new THREE.PerspectiveCamera(
          70,
          window.innerWidth / window.innerHeight,
          0.1,
          2000
        );

        // === RENDERER ===
        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        document.body.appendChild(renderer.domElement);

        // === LIGHTS ===
        const hemiLight = new THREE.HemisphereLight(0xffffff, 0x666688, 0.9);
        scene.add(hemiLight);

        const sunLight = new THREE.DirectionalLight(0xffffff, 1.2);
        sunLight.position.set(100, 150, -100);
        sunLight.castShadow = true;
        sunLight.shadow.mapSize.width = 4096;
        sunLight.shadow.mapSize.height = 4096;
        sunLight.shadow.camera.near = 1;
        sunLight.shadow.camera.far = 500;
        sunLight.shadow.camera.left = -200;
        sunLight.shadow.camera.right = 200;
        sunLight.shadow.camera.top = 200;
        sunLight.shadow.camera.bottom = -200;
        scene.add(sunLight);

        // === GROUND ===
        const ground = new THREE.Mesh(
          new THREE.PlaneGeometry(400, 400, 64, 64),
          new THREE.MeshPhysicalMaterial({
            color: 0xe0dfd5,
            roughness: 0.8,
            metalness: 0.1,
          })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.receiveShadow = true;
        scene.add(ground);

        // === ROADS ===
        const roadMat = new THREE.MeshPhysicalMaterial({
          color: 0x2f2f2f,
          roughness: 0.5,
          metalness: 0.3,
        });
        const roadWidth = 12;
        const gridSpacing = 40;

        function createRoad(w, h, x, z) {
          const road = new THREE.Mesh(
            new THREE.BoxGeometry(w, 0.05, h, 8, 1, 8),
            roadMat
          );
          road.position.set(x, 0.025, z);
          road.receiveShadow = true;
          scene.add(road);
        }

        for (let i = -100; i <= 100; i += gridSpacing)
          createRoad(roadWidth, 300, i, 0);
        for (let j = -100; j <= 100; j += gridSpacing)
          createRoad(300, roadWidth, 0, j);

        // === BUILDINGS ===
        function createBuilding(x, z, w, h, d, color) {
          const mat = new THREE.MeshPhysicalMaterial({
            color: color || 0xbcbcbc,
            roughness: 0.5,
            metalness: 0.2,
            clearcoat: 0.4,
          });
          const geo = new THREE.BoxGeometry(w, h, d, 6, 6, 6);
          const building = new THREE.Mesh(geo, mat);
          building.position.set(x, h / 2, z);
          building.castShadow = true;
          building.receiveShadow = true;
          scene.add(building);
        }

        for (let i = -80; i <= 80; i += gridSpacing) {
          createBuilding(i, -60, 14, 15 + Math.random() * 10, 14);
          createBuilding(i, 60, 14, 15 + Math.random() * 10, 14);
        }

        // === TREES (smooth high-poly) ===
        function createTree(x, z) {
          const trunk = new THREE.Mesh(
            new THREE.CylinderGeometry(0.4, 0.5, 2, 16),
            new THREE.MeshPhysicalMaterial({ color: 0x8b5a2b })
          );
          trunk.position.set(x, 1, z);
          const leaves = new THREE.Mesh(
            new THREE.SphereGeometry(1.5, 24, 24),
            new THREE.MeshPhysicalMaterial({
              color: 0x228b22,
              roughness: 0.8,
              metalness: 0.2,
            })
          );
          leaves.position.set(x, 3, z);
          trunk.castShadow = true;
          leaves.castShadow = true;
          scene.add(trunk, leaves);
        }

        for (let z = -100; z <= 100; z += 12) {
          createTree(-20, z);
          createTree(20, z);
        }

        // === SCHOOL ===
        const school = new THREE.Mesh(
          new THREE.BoxGeometry(20, 12, 15, 8, 8, 8),
          new THREE.MeshPhysicalMaterial({
            color: 0xffc1a1,
            roughness: 0.4,
            clearcoat: 0.3,
          })
        );
        school.position.set(0, 6, -40);
        school.castShadow = true;
        scene.add(school);

        // === SCHOOL LABEL ===
        const loader = new THREE.FontLoader();
        loader.load(
          "https://threejs.org/examples/fonts/helvetiker_regular.typeface.json",
          (font) => {
            const geo = new THREE.TextGeometry("School", {
              font,
              size: 2,
              height: 0.4,
            });
            const mat = new THREE.MeshPhysicalMaterial({ color: 0x222222 });
            const text = new THREE.Mesh(geo, mat);
            text.position.set(10, 5, -34);
            text.rotation.y = Math.PI / 2;
            text.castShadow = true;
            scene.add(text);
          }
        );

        // === SCHOOL ZONE SIGN ===
        const textureLoader = new THREE.TextureLoader();
        textureLoader.load("images.png", (texture) => {
          const pole = new THREE.Mesh(
            new THREE.CylinderGeometry(0.08, 0.08, 4, 16),
            new THREE.MeshPhysicalMaterial({ color: 0x333333 })
          );
          const board = new THREE.Mesh(
            new THREE.PlaneGeometry(2.5, 2.5),
            new THREE.MeshPhysicalMaterial({
              map: texture,
              roughness: 0.4,
              metalness: 0.1,
              side: THREE.DoubleSide,
            })
          );
          pole.position.set(0, 2, 0);
          board.position.set(0, 4.5, 0);
          const group = new THREE.Group();
          group.add(pole, board);
          group.position.set(27, 0, -30);
          group.rotation.y = -Math.PI / 2;
          scene.add(group);
        });

        // === ZEBRA CROSS ===
        const stripeMat = new THREE.MeshStandardMaterial({ color: 0xffffff });
        for (let i = 13; i <= 27; i += 1.2) {
          const stripe = new THREE.Mesh(
            new THREE.BoxGeometry(1, 0.05, 1),
            stripeMat
          );
          stripe.position.set(i, 0.03, -30);
          scene.add(stripe);
        }

        // === CONTROLS ===
        controls = new THREE.PointerLockControls(camera, document.body);
        scene.add(controls.getObject());
        document.body.addEventListener("click", () => controls.lock());

        // === EVENTS ===
        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);
        window.addEventListener("resize", onWindowResize);

        // Initial camera
        controls.getObject().position.set(0, 2, 20);
      }

      function onKeyDown(e) {
        switch (e.code) {
          case "KeyW":
            moveForward = true;
            break;
          case "KeyS":
            moveBackward = true;
            break;
          case "KeyA":
            moveLeft = true;
            break;
          case "KeyD":
            moveRight = true;
            break;
          case "ShiftLeft":
            sprint = true;
            break;
        }
      }

      function onKeyUp(e) {
        switch (e.code) {
          case "KeyW":
            moveForward = false;
            break;
          case "KeyS":
            moveBackward = false;
            break;
          case "KeyA":
            moveLeft = false;
            break;
          case "KeyD":
            moveRight = false;
            break;
          case "ShiftLeft":
            sprint = false;
            break;
        }
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);
        const delta = clock.getDelta();

        velocity.x -= velocity.x * 10.0 * delta;
        velocity.z -= velocity.z * 10.0 * delta;

        direction.z = Number(moveForward) - Number(moveBackward);
        direction.x = Number(moveRight) - Number(moveLeft);
        direction.normalize();

        const speed = sprint ? 120.0 : 50.0;
        if (moveForward || moveBackward)
          velocity.z -= direction.z * speed * delta;
        if (moveLeft || moveRight) velocity.x -= direction.x * speed * delta;

        controls.moveRight(-velocity.x * delta);
        controls.moveForward(-velocity.z * delta);
        controls.getObject().position.y = 2;

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>
